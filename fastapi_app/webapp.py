import os
import json
import io

import jsonschema.exceptions
from fastapi import FastAPI, Request, Response, File, UploadFile, HTTPException
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import StreamingResponse
from fastapi.responses import JSONResponse
import importlib.util
from fastapi.responses import JSONResponse
from jsonschema import validate

try:
    from worker import app as celery_app
except ModuleNotFoundError:
    from .worker import app as celery_app
import celery.states as states

app = FastAPI()

SERVER_ROOT = os.path.dirname(__file__)

app.mount(
    "/static", StaticFiles(directory=os.path.join(SERVER_ROOT, "static")), name="static"
)

templates = Jinja2Templates(directory=os.path.join(SERVER_ROOT, "templates"))


# option for routing `@app.X` where `X` is one of
# post: to create data.
# get: to read data.
# put: to update data.
# delete: to delete data.

# while it might be tempting to use BackgroundTasks for oemof simulation, those might take up
# resources and it is better to start them in an independent process. BackgroundTasks are for
# not resource intensive processes(https://fastapi.tiangolo.com/tutorial/background-tasks/)


# `127.0.0.1:8000/docs` endpoint will have autogenerated docs for the written code

# Test Driven Development --> https://fastapi.tiangolo.com/tutorial/testing/

def validate_simulation_queue(queue):
    if queue not in ["grid", "supply"]:
        raise HTTPException(status_code=400, detail=f'{queue} is not an accepted argument. Simulation options are "grid" or "supply"')
    return

@app.get("/")
def index(request: Request) -> Response:

    return templates.TemplateResponse(
        "index.html",
        {
            "request": request,
        },
    )

@app.post("/sendjson/{queue}")
async def simulate_json_variable(request: Request, queue: str = "supply"):
    """Receive mvs simulation parameter in json post request and send it to simulator"""
    validate_simulation_queue(queue)
    input_dict = await request.json()

    # send the task to celery
    task = celery_app.send_task(
        f"{queue}.run_simulation", args=[input_dict], queue=queue, kwargs={}
    )
    queue_answer = await check_task(task.id)

    return queue_answer


@app.post("/uploadjson/{queue}")
def simulate_uploaded_json_files(
    request: Request, queue: str, json_file: UploadFile = File(...),
):
    """Receive mvs simulation parameter in json post request and send it to simulator
    the value of `name` property of the input html tag should be `json_file` as the second
    argument of this function
    """
    json_content = jsonable_encoder(json_file.file.read())
    return run_simulation(request, input_json=json_content, queue=f"{queue}")


def run_simulation(request: Request, input_json=None, queue="supply") -> Response:
    """Send a simulation task to a celery worker"""

    if input_json is None:
        input_dict = {
            "name": "dummy_json_input",
            "secondary_dict": {"val1": 2, "val2": [5, 6, 7, 8]},
        }
    else:
        input_dict = json.loads(input_json)

    # validate input against JSONSchema
    variant = "input" if queue == "supply" else "default"
    schema = json.loads(get_schema(queue, variant).body)
    try:
        validate(input_dict, schema)
    except jsonschema.exceptions.ValidationError:
        raise HTTPException(status_code=400, detail=f'Input did not validate against JSONSchema. Hint: You can check the expected JSON format using the "/schema/grid/input" and "/schema/supply/input" endpoints.')

    # send the task to celery
    task = celery_app.send_task(
        f"{queue}.run_simulation", args=[input_dict], queue=queue, kwargs={}
    )

    return templates.TemplateResponse(
        "submitted_task.html", {"request": request, "task_id": task.id}
    )



@app.get("/check/{task_id}")
async def check_task(task_id: str) -> JSONResponse:
    res = celery_app.AsyncResult(task_id)
    task = {
        "server_info": None,
        "id": task_id,
        "status": res.state,
        "results": None,
    }
    if res.state == states.PENDING:
        task["status"] = res.state
    else:
        task["status"] = "DONE"
        results_as_dict = json.loads(res.result)
        server_info = results_as_dict.pop("SERVER")
        task["server_info"] = server_info
        task["results"] = results_as_dict
        if "ERROR" in task["results"]:
            task["status"] = "ERROR"
            task["results"] = results_as_dict

    return JSONResponse(content=jsonable_encoder(task))


@app.get("/abort/{task_id}")
async def revoke_task(task_id: str) -> JSONResponse:
    res = celery_app.AsyncResult(task_id)
    res.revoke(terminate=True)
    return JSONResponse(content=jsonable_encoder({"task_id": task_id, "aborted": True}))


@app.get("/schema/{queue}/{variant}")
def get_schema(queue: str, variant: str):
    schema_file = f"{queue}_schema"
    schema_path = os.path.join(os.path.dirname(__file__), "static", f"{schema_file}.py")

    if not os.path.isfile(schema_path):
        raise HTTPException(status_code=404, detail=f"Schema file '{schema_file}' not found")

    try:
        spec = importlib.util.spec_from_file_location(schema_file, schema_path)
        schema_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(schema_module)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error while loading the module: {e}")

    schema_var = f"{schema_file}_{variant}"

    if not hasattr(schema_module, schema_var):
        raise HTTPException(status_code=404, detail=f"Schema variable '{schema_var}' not found in {schema_file}")

    return JSONResponse(content=getattr(schema_module, schema_var))

